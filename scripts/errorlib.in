# -*- perl -*-
# $Id: errorlib.in,v 1.52 2005/10/06 03:46:13 ajt Exp $

use Mail::Address;
use Debbugs::MIME qw(decode_rfc1522 encode_rfc1522);
use Debbugs::Packages qw(:all);
use Debbugs::Common qw(:all);
use Debbugs::Status qw(:all);

sub F_SETLK { 6; } sub F_WRLCK{ 1; }
$flockstruct= 'sslll'; # And there ought to be something for this too.

sub unlockreadbugmerge {
    local ($rv) = @_;
    &unfilelock if $rv >= 2;
    &unfilelock if $rv >= 1;
}

sub lockreadbugmerge {
    local ($lref, $location) = @_;
    local $data;
    if (!($data = &lockreadbug($lref, $location))) { return ( 0, undef ); }
    if (!length($data->{mergedwith})) { return ( 1, $data ); }
    &unfilelock;
    &filelock('lock/merge');
    if (!&lockreadbug($lref, $location)) { &unfilelock; return ( 0, undef ); }
    return ( 2, $data );
}

%saniarray= ('<','lt', '>','gt', '&','amp', '"','quot');

sub sani {
    my ($in) = @_;
    warn "You should be using HTML::Entities instead.";
    $in =~ s/([<>&"])/$saniarray{$1}/g;
    return $in;
}

sub getmailbody {
	my $entity = shift;
	my $type = $entity->effective_type;
	if ($type =~ m#text/(?!html|enriched)# or
	    $type eq 'application/pgp') {
		return $entity->bodyhandle;
	} elsif ($type eq 'multipart/alternative') {
		# RFC 2046 says we should use the last part we recognize.
		for my $part (reverse $entity->parts) {
			my $ret = getmailbody($part);
			return $ret if $ret;
		}
	} else {
		# For other multipart types, we just pretend they're
		# multipart/mixed and run through in order.
		for my $part ($entity->parts) {
			my $ret = getmailbody($part);
			return $ret if $ret;
		}
	}
	return undef;
}

sub get_addresses {
	return
	    map { $_->address() }
	    map { Mail::Address->parse($_) } @_;
}

sub escapelog {
	my @log = @_;
	map { s/^([\01-\07\030])/\030$1/gm } @log;
	return \@log;
}

sub isstrongseverity {
    my $severity = shift;
    $severity = $gDefaultSeverity if $severity eq '';
    return grep { $_ eq $severity } @gStrongSeverities;
}


@severities= grep { not exists $gObsoleteSeverities{$_} } @gSeverityList;
@showseverities= @severities;
grep ($_= $_ eq '' ? $gDefaultSeverity : $_, @showseverities);
%displayshowseverities= %gSeverityDisplay;

# compatibility
if (defined $gFowardList and not defined $gForwardList) {
    $gForwardList = $gFowardList;
}

1;
