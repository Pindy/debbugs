#!/usr/bin/perl
# $Id: expire.in,v 1.5 1999/09/20 05:40:07 gecko Exp $

# Load modules and set envirnment
require('/etc/debbugs/config');
require('/usr/lib/debbugs/errorlib');
use File::Copy;
$ENV{'PATH'}= '/usr/lib/debbugs'.$ENV{'PATH'};
chdir("$gSpoolDir") || die "chdir spool: $!\n";

#global variables
$debug = 0;
defined($startdate= time) || &quit("failed to get time: $!");

sub get_archivename
{	my $bugnum = shift;
	my $archivename = "";

#	while( $bugnum > 99 ) { $bugnum = int $bugnum/10; }
	$bugnum = $bugnum % 100;
	$archivename = sprintf "%02d", $bugnum;
	return $archivename;
}
	
#get list of bugs (ie, status files)
opendir(DIR,"db") || &quit("opendir db: $!\n");
@list= grep(m/^\d+\.status$/,readdir(DIR));
grep(s/\.status$//,@list);
@list= sort { $a <=> $b } @list;

#process each bug (ie, status file)
while (length($ref=shift(@list))) 
{ 	print STDERR "$ref considering\n" if $debug;
    $bfound= &lockreadbugmerge($ref);
	print STDERR "$ref read $bfound\n" if $debug;
    $bfound || next;
	print "$ref read ok (done $s_done)\n" if $debug;
    (&unlockreadbugmerge($bfound), next) unless length($s_done);
	print "$ref read done\n" if $debug;
    @aref= ($ref);
    if (length($s_mergedwith)) { push(@aref,split/ /,$s_mergedwith); }
	print "$ref aref @aref\n" if $debug;
    $oktoremove= 1;
    for $mref (@aref) 
	{	print "$ref $mref check\n" if $debug;
        if ($mref != $ref) 
		{ 	print "$ref $mref reading\n" if $debug;
            &lockreadbug($mref) || die "huh ?";
			print "$ref $mref read ok\n" if $debug;
            $bfound++;
        }
		print "$ref $mref read/not\n" if $debug;
        $expectmerge= join(' ',grep($_ != $mref, sort { $a <=> $b } @aref));
        $s_mergedwith eq $expectmerge ||
            die "$ref -> $mref: ($s_mergedwith) vs. ($expectmerge) (@aref)";
		print "$ref $mref merge-ok\n" if $debug;
        length($s_done) || die "$ref -> $mref";
		print "$ref $mref done-ok\n" if $debug;
        $days= -M "db/$mref.log";
		print "ref $mref days $days\n" if $debug;
        if ($days <= $gRemoveAge) 
			{ print "$ref $mref saved\n" if $debug; $oktoremove= 0;}
    }
    if ($oktoremove) 
	{	print "$ref removing\n" if $debug;
        for $mref (@aref) 
		{ 	print "$ref removing $mref\n" if $debug;
			if ( $gSaveOldBugs )
			{
				my $dir;
				$dir = "archive/" . get_archivename $mref;
				`mkdir -p "$dir"`;
				copy( "db/$mref.log", "$dir/$mref.log" );
				copy( "db/$mref.status", "$dir/$mref.status" );
				copy( "db/$mref.report", "$dir/$mref.report" );
				if ( open( IDXFILE, ">>archive/index" ) )
				{	printf IDXFILE "%s %d %s\n", $s_package, $mref, $s_subject;
					close IDXFILE;
				} else { print "Unable to write to index file\n"; }
				
            	print("archived $mref to $dir (from $ref)\n") || &quit("output old: $!");
			}
            unlink("db/$mref.log", "db/$mref.status", "db/$mref.report");
            print("deleted $mref (from $ref)\n") || &quit("output old: $!");
        }
    }
	print "$ref unlocking $bfound\n" if $debug;
    for ($i=0; $i<$bfound; $i++) { &unfilelock; }
	print "$ref unlocking done\n" if $debug;
}

close(STDOUT) || &quit("close stdout: $!");
