#!/usr/bin/perl
# $Id: processall.in,v 1.7 2001/08/16 07:20:18 doogie Exp $
#
# Usage: processall
#
# Uses up: incoming/I<code><bugnum>.nn
# Temps:   incoming/[GP].nn
# Creates: incoming/E.nn
# Stop;    process/stop

$config_path = '/org/bugs.debian.org/etc';
$lib_path = '/org/bugs.debian.org/scripts';

require "$config_path/config";
require "$lib_path/errorlib";
$ENV{'PATH'} = $lib_path.':'.$ENV{'PATH'};

chdir( "$gSpoolDir" ) || die 'chdir spool: $!\n';
push( @INC, "$lib_path" );

#open(DEBUG,">&4");

umask(002);

$|=1;
undef %fudged;

&filelock('incoming-cleaner');
for (;;) {
    if (-f 'stop') {
        print(STDERR "stop file created\n") || die $!;
        last;
    }
    if (!@ids) {
        opendir(DIR,"incoming") || die $!;
        while ( defined( $_= readdir(DIR) )) { push(@ids,$_) if s/^I//; }
        last unless @ids;
        @ids= sort(@ids);
    }
    stat("$gMaintainerFile") || die "stat $gMaintainerFile: $!\n";
    $nf= @ids;
    $id= shift(@ids);
    unless (rename("incoming/I$id","incoming/G$id")) {
        if ($fudged{$id}) {
            die "$id already fudged once! $!\n";
        }
        $fudged{$id}= 1;
        next;
    }
    if ($id =~ m/^[RC]/) {
        print(STDOUT "[$nf] $id service ...") || die $!;
        defined($c=fork) || die $!;
        if (!$c) { exec("$lib_path/service",$id); die $!; }
    } elsif ($id =~ m/^[BMQFDU]/) {
        print(STDOUT "[$nf] $id process ...") || die $!;
        defined($c=fork) || die $!;
        if (!$c) { exec("$lib_path/process",$id); die $!; }
    } else {
        die "bad name $id";
    }
    $cc=waitpid($c,0); $cc == $c || die "$cc $c $!";
    $status=$?;
    if ($status) {
        print(STDERR "$id: process failed ($status $!) - now in [PG]$id\n") || die $!;
    }
    print(STDOUT " done\n") || die $!;
    $ndone++;
}
&unfilelock;

exit(0);
